# Java设计模式

### Java反射

* 在Java中，反射是通过包java. lang . reflect,*来实现的

* 反射机制：在运行状态中，对任意一个类都能知道该类所有属性和方法，且对任意一个对象，都能调用它的任意一个方法（动态获取信息及动态调用对象方法）

### 动态代理模式和责任链模式

#### 代理模式

* 代理作用：在真实对象访问之前或之后加入对应的逻辑，或根据其他规则决定是否使用真实对象
* 调用者-->代理对象-->真实对象
* 代理步骤
  * 代理对象和真实对相关建立代理关系
  * 实现代理对象的代理逻辑方法

* 常用动态代理：JDK和CGLIB

#### JDK动态代理

* 需借助接口产生代理对象，先定义接口
* 建立代理对象与真实对象之间的关系，用bind方法，生成代理对象proxy
* 实现代理逻辑，用invoke方法，包含3个参数，控制真实对象的访问
  * proxy 代理对象，bind方法生成对象
  * method 当前调度的方法
  * args 调度方法的参数

* 代理对象调用真实对象的方法时会进入到invoke方法（代理逻辑方法）中，在根据invoke内容判断是否调用真实对象的方法

#### CGLIB动态代理

* 不需要提供接口，只要一个非抽象类
* 通过getProxy方法生成代理对象
* 通过intercept实现代理逻辑方法决定是否调用真实对象方法

#### 拦截器

题外话：System.err.println()与System.out.println()的区别

* out为标准输出流，带有缓存，由JVM和操作系统共同决定何时输出

* err为标准错误输出流，不带缓存，直接输出

程序设计者会设计拦截器接口供开发者使用，开发者只要知道拦截器接口方法、含义和作用即可

无须知道动态代理是怎么实现的

```
* 拦截器工作流程
* 1 bind方法用JDK动态代理绑定对象，返回代理对象
* 2 如果没有设置拦截器，则直接反射真实对象的方法，然后结束。否则进行步骤3
* 3 通过反射生成拦截器，并准备使用它
* 4 调用拦截器的before方法，若返回true，反射原来的方法，否则运行拦截器的around方法
* 5 调用拦截器的after方法
* 6 返回结果
```

#### 责任链

